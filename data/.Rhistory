),
print(index01)
)
}
for( i in 1:5){
ifelse( ( i - 1 ) == 0 ,
index01 <- c( (i+1):N ),
ifelse( i == N,
index01 <- c( 1:(i-1)  ),
index01 <- c( 1:(i-1) , (i+1):N )
)
)
print(index01)
}
random.walk.closeness.centrality(io)
s <- random.walk.closeness.centrality(io)
random.walk.closeness.centrality <- function( A ){
N <- nrow( A )
H <- matrix( 0, nrow = N, ncol = N )
A <- diag( N ) - solve( diag( colSums( A ) ) ) %*% A
I <- solve( A[2:N,2:N] )
for( i in 1:N ){
ifelse( ( i - 1 ) == 0 ,
index01 <- c( (i+1):N ),
ifelse( i == N,
index01 <- c( 1:(i-1)  ),
index01 <- c( 1:(i-1) , (i+1):N )
)
)
ifelse( (i+2) > N,
index02 <- c( 1:i  ),
index02 <- c( 1:i , (i+2):N )
)
H[index01,i] <- I %*% rep(1, ( N - 1 ) )
if( i < N ){
u   <- A[ index02, i  ] - A[ index01, (i+1) ]
n01 <- as.numeric( ( 1 + I[ i , ] %*% u ) )
I   <- I - ( ( I %*% u ) %*% I[ i , ]  ) / n01
v   <- A[ i , index02 ] - A[ (i+1), index01 ]
n02 <-  as.numeric(  ( 1+ v %*% I[,i] ) )
I   <- I - ( I[ ,i] %*% ( v %*% I ) ) / n02
I   <- solve( A[index02, index02 ]  )
if( any(is.infinite( I ) ) ){
I <- solve( A[ index02, index02 ] )
}
}
}
final.result <- N / colSums(H)
return( final.result )
}
s <- random.walk.closeness.centrality(io)
plot(s)
zero
random.walk.closeness.centrality <- function( A ){
N <- nrow( A )
H <- matrix( 0, nrow = N, ncol = N )
A <- diag( N ) - solve( diag( colSums( t(A) ) ) ) %*% A
I <- solve( A[2:N,2:N] )
for( i in 1:N ){
ifelse( ( i - 1 ) == 0 ,
index01 <- c( (i+1):N ),
ifelse( i == N,
index01 <- c( 1:(i-1)  ),
index01 <- c( 1:(i-1) , (i+1):N )
)
)
ifelse( (i+2) > N,
index02 <- c( 1:i  ),
index02 <- c( 1:i , (i+2):N )
)
H[index01,i] <- I %*% rep(1, ( N - 1 ) )
if( i < N ){
u   <- A[ index02, i  ] - A[ index01, (i+1) ]
n01 <- as.numeric( ( 1 + I[ i , ] %*% u ) )
I   <- I - ( ( I %*% u ) %*% I[ i , ]  ) / n01
v   <- A[ i , index02 ] - A[ (i+1), index01 ]
n02 <-  as.numeric(  ( 1+ v %*% I[,i] ) )
I   <- I - ( I[ ,i] %*% ( v %*% I ) ) / n02
I   <- solve( A[index02, index02 ]  )
if( any(is.infinite( I ) ) ){
I <- solve( A[ index02, index02 ] )
}
}
}
final.result <- N / colSums(H)
return( final.result )
}
s <- random.walk.closeness.centrality(io)
plot(s)
zero <- c( which( out.list == 0 | out.list == 1)
)
out.list         <- rowSums(adjacency.matrix)
N <- nrow(adjacency.matrix)
zero <- c( which( out.list == 0 | out.list == 1)
)
zero
in.list          <- colSums(adjacency.matrix)
zero <- which( out.list == 0 && in.list == 0 )
zero
in.list
zero <- which( out.list == 0 & in.list == 0 )
zero
absorbing <- which( out.list > 2 & in.list > 0 )
absorbing
absorbing <- which( out.list < 2 & in.list > 0 )
absorbing
all.sectors <- 1:N
rw.closeness <- random.walk.closeness.centrality(iot.clean)
Convert data frame to class matrix and delete column names
iot <- as.matrix( iot )
N   <- nrow( iot )
colnames(test) <- NULL
# Compute binary adjacency matrix and both in and outlist
adjacency.matrix <- ifelse( test > 0 , 1 , 0 )
out.list         <- rowSums(adjacency.matrix)
in.list          <- colSums(adjacency.matrix)
# Find unconnected and absorbing nodes
zero      <- which( out.list == 0 & in.list == 0 )
absorbing <- which( out.list  < 2 & in.list  > 0 )
drops     <- c( zero, absorbing )
# Clean IOT - Drop found sectors
all.sectors <- 1:N
keeps       <- setdiff( all.sectors , drops )
iot.clean   <- iot[ keeps , keeps ]
rw.closeness <- random.walk.closeness.centrality(iot.clean)
rw.counting  <- random.walk.counting.centrality(iot.clean)
iot.clean
class(iot.clean)
iot <- as.matrix( iot )
iot.clean   <- as.matrix( iot[ keeps , keeps ] )
rw.closeness <- random.walk.closeness.centrality(iot.clean)
rw.counting  <- random.walk.counting.centrality(iot.clean)
v  <- c(1,2,3,4)
append(v,3,3)
append(v,3,2)
append(v,3,4)
sapply(1:length(drops), function( i ){ append( rw.closeness, 0, drops[i]-1  )})
58 == drops
if( any( i == drops)){print(i)}
i
i=58
if( any( i == drops)){print(i)}
rwclo <- random.walk.closeness.centrality(iot.clean)
rwclose <- random.walk.closeness.centrality(iot.clean)
rwcount <- random.walk.counting.centrality(iot.clean)
# Adjust output
rw.closeness <- c( )
rw.counting  <- c( )
for( i in all.sectors ){
if( i == any( drops ) ){
rw.closeness[i] <- 0
rw.counting[i]  <- 0
} else {
rw.closeness[i] <- rwclose[i]
rw.counting[i]  <- rwcount[i]
}
}
rw.closeness
drops
all.sectors
for(i in 0:(length(drops)-1))
probes <- append(rwclose, FALSE, after=(drops[i+1]+i))
probes
append(3,1)
append(c(3,1),1)
a <- c(1,2,3)
a <- c(1,2,3)
i <- 1
while ( length(a) < 5  ) {
a <- append(a,i)
i <- i+1
}
a
rw.closeness <- c( )
a
setdiff(a,1)
rw.closeness <- c( )
rw.counting  <- c( )
drop.counter <- drops
i <- 1
j <- 1
while ( length(rw.closeness) < ( N + 1)  ) {
bool <- i == drop.counter
if( any( drops ) ){
pos <- which( bool == i )
drop.counter <- setdiff( drop.counter, drop.counter[pos] )
rw.closeness[i] <- 0
rw.counting[i]  <- 0
} else {
rw.closeness[i] <- rwclose[j]
rw.counting[i]  <- rwcount[j]
j <- j + 1
}
i <- i+1
}
rw.closeness
rw.closeness <- c( )
rw.counting  <- c( )
drop.counter <- drops
i <- 1
j <- 1
while ( length(rw.closeness) < ( N + 1)  ) {
bool <- i == drop.counter
if( any( drops ) ){
pos <- which( bool == i )
drop.counter <- setdiff( drop.counter, drop.counter[pos] )
rw.closeness[i] <- 0
rw.counting[i]  <- 0
} else {
rw.closeness[i] <- rwclose[j]
rw.counting[i]  <- rwcount[j]
j <- j + 1
}
print(i)
print(j)
i <- i+1
}
drop.counter
rw.closeness <- c( )
rw.counting  <- c( )
drop.counter <- drops
i <- 1
j <- 1
while ( length(rw.closeness) < ( N + 1)  ) {
bool <- i == drop.counter
print(bool)
if( any( drops ) ){
pos <- which( bool == i )
drop.counter <- setdiff( drop.counter, drop.counter[pos] )
rw.closeness[i] <- 0
rw.counting[i]  <- 0
} else {
rw.closeness[i] <- rwclose[j]
rw.counting[i]  <- rwcount[j]
j <- j + 1
}
i <- i+1
}
bool
any(bool)
u
i
i <- 1
bool <- i == drop.counter
print(bool)
if( any( drops ) ){
pos <- which( bool == i )
drop.counter <- setdiff( drop.counter, drop.counter[pos] )
rw.closeness[i] <- 0
rw.counting[i]  <- 0
} else {
rw.closeness[i] <- rwclose[j]
rw.counting[i]  <- rwcount[j]
j <- j + 1
}
j
rw.closeness <- c( )
rw.counting  <- c( )
drop.counter <- drops
i <- 1
j <- 1
while ( i < ( N + 1)  ) {
bool <- i == drop.counter
print(bool)
if( any( drops ) == TRUE ){
pos <- which( bool == i )
drop.counter <- setdiff( drop.counter, drop.counter[pos] )
rw.closeness[i] <- 0
rw.counting[i]  <- 0
} else {
rw.closeness[i] <- rwclose[j]
rw.counting[i]  <- rwcount[j]
j <- j + 1
}
i <- i+1
}
rw.closeness
rw.closeness <- c( )
rw.counting  <- c( )
drop.counter <- drops
i <- 1
j <- 1
while ( i < ( N + 1)  ) {
bool <- i == drop.counter
print(bool)
if( any( bool ) ){
pos <- which( bool == i )
drop.counter <- setdiff( drop.counter, drop.counter[pos] )
rw.closeness[i] <- 0
rw.counting[i]  <- 0
} else {
rw.closeness[i] <- rwclose[j]
rw.counting[i]  <- rwcount[j]
j <- j + 1
}
i <- i+1
}
rw.closeness
which(rw.closeness)
which(rw.closeness==0)
drops
length(rw.closeness)
# Initialize empty node list
node.list <- c( )
# Compute and format nodes
for( i in 1:N ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],
'clo',rw.closeness[i],'cou',rw.counting[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],
'clo',rw.closeness[i],'cou',rw.counting[i],'}')
)
}
sector <- read.csv( 'product_groups.csv', sep = ';', header = FALSE )
sector
as.vector(sector)
sector <-  as.vector(sector)
sector
sector[1]
sector <-  c(sector)
sector
sector[1]
node.list <- c( )
# Compute and format nodes
for( i in 1:N ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],
'clo',rw.closeness[i],'cou',rw.counting[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],
'clo',rw.closeness[i],'cou',rw.counting[i],'}')
)
}
sector <- read.csv( 'product_groups.csv', sep = ';', header = FALSE )
# Compute and format nodes
for( i in 1:N ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],
'clo',rw.closeness[i],'cou',rw.counting[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],
'clo',rw.closeness[i],'cou',rw.counting[i],'}')
)
}
# Initialize empty node list
node.list <- c( )
# Compute and format nodes
for( i in 1:N ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],
'clo',rw.closeness[i],'cou',rw.counting[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],
'clo',rw.closeness[i],'cou',rw.counting[i],'}')
)
}
# Initialize empty node list
node.list <- c( )
# Compute and format nodes
for( i in 1:N ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
'clo',rw.closeness[i],'cou',rw.counting[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
'clo',rw.closeness[i],'cou',rw.counting[i],'}')
)
}
node.list
# Initialize empty node list
node.list <- c( )
# Compute and format nodes
for( i in 1:N ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i],',cou:',rw.counting[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i],',cou:',rw.counting[i],'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
node.list[1]
summary(rw.counting)
log(rw.counting)
# Initialize empty edge list
edge.list <- c(NA)
# Compute edge list for java script
for( i in 1:N){
# Compute out list for node i
temp.out.list <- adjacency.matrix[i,]
# Loop over adjacent nodes j of node i
for( j in 1:N ){
# If there is an edge append to list
if(  temp.out.list[j] != 0 ){
edge <- paste0('{ source:',(i-1),', target:',(j-1),'},')
current.index <- length(edge.list) + 1
edge.list[current.index] <- edge
}
}
# Last iteration add no comma
if( i == N ){
last.index <- current.index - 1
edge.list[last.index] <- paste0('{ source:',(i-1),', target:',(j-1),'}')
edge.list <- edge.list[2:last.index]
}
}
# Design final output
open   <- "var dataset = { nodes: ["
bridge <-  "],edges: ["
close  <- "]};"
graph  <- noquote( c( open , node.list , bridge , edge.list , close ) )
graph
head(edge.list)
setwd( '/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/App/data/' )
# Save data to HD
write( graph , 'graph_data.js' )
head(node.list)
options( useFancyQuotes = FALSE )
# Initialize empty node list
node.list <- c( )
# Compute and format nodes
for( i in 1:N ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i],',cou:',rw.counting[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i],',cou:',rw.counting[i],'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
# Initialize empty edge list
edge.list <- c(NA)
# Compute edge list for java script
for( i in 1:N){
# Compute out list for node i
temp.out.list <- adjacency.matrix[i,]
# Loop over adjacent nodes j of node i
for( j in 1:N ){
# If there is an edge append to list
if(  temp.out.list[j] != 0 ){
edge <- paste0('{ source:',(i-1),', target:',(j-1),'},')
current.index <- length(edge.list) + 1
edge.list[current.index] <- edge
}
}
# Last iteration add no comma
if( i == N ){
last.index <- current.index - 1
edge.list[last.index] <- paste0('{ source:',(i-1),', target:',(j-1),'}')
edge.list <- edge.list[2:last.index]
}
}
# Design final output
open   <- "var dataset = { nodes: ["
bridge <-  "],edges: ["
close  <- "]};"
graph  <- noquote( c( open , node.list , bridge , edge.list , close ) )
################################################################################
################################################################################
# Reset working directory for output
setwd( '/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/App/data/' )
# Save data to HD
write( graph , 'graph_data.js' )
head(node.list)
rw.closeness*100
rw.closeness*1000
rw.closeness*500
rw.closeness*800
Initialize empty node list
node.list <- c( )
# Compute and format nodes
for( i in 1:N ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i] * 1000 ,',cou:',rw.counting[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i] * 1000,',cou:',rw.counting[i],'}')
)
}
node.list <- noquote(node.list)
head(node.list)
# Initialize empty edge list
edge.list <- c(NA)
# Compute edge list for java script
for( i in 1:N){
# Compute out list for node i
temp.out.list <- adjacency.matrix[i,]
# Loop over adjacent nodes j of node i
for( j in 1:N ){
# If there is an edge append to list
if(  temp.out.list[j] != 0 ){
edge <- paste0('{ source:',(i-1),', target:',(j-1),'},')
current.index <- length(edge.list) + 1
edge.list[current.index] <- edge
}
}
# Last iteration add no comma
if( i == N ){
last.index <- current.index - 1
edge.list[last.index] <- paste0('{ source:',(i-1),', target:',(j-1),'}')
edge.list <- edge.list[2:last.index]
}
}
# Design final output
open   <- "var dataset = { nodes: ["
bridge <-  "],edges: ["
close  <- "]};"
graph  <- noquote( c( open , node.list , bridge , edge.list , close ) )
################################################################################
################################################################################
# Reset working directory for output
setwd( '/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/App/data/' )
# Save data to HD
write( graph , 'graph_data.js' )
